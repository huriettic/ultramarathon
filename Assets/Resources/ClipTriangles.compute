#pragma kernel CSMain

struct Triangle
{
    float3 v0, v1, v2;
    float4 uv0, uv1, uv2;
};

struct MathematicalPlane
{
    float3 normal;
    float distance;
};

struct PolygonMeta
{
    int lineStartIndex;
    int lineCount;

    int opaqueStartIndex;
    int opaqueCount;

    int collisionStartIndex;
    int collisionCount;

    int connectedSectorID;
    int sectorID;

    int planeStartIndex;
    int planeCount;
    
    int plane;
};

AppendStructuredBuffer<Triangle> outputTriangleBuffer;
StructuredBuffer<Triangle> inputTriangleBuffer;
StructuredBuffer<MathematicalPlane> planeBuffer;
StructuredBuffer<PolygonMeta> inputPolygonBuffer;
RWStructuredBuffer<float3> processVertices;
RWStructuredBuffer<float4> processTextures;
RWStructuredBuffer<int> processBool;
RWStructuredBuffer<float3> temporaryVertices;
RWStructuredBuffer<float4> temporaryTextures;
RWByteAddressBuffer argsBuffer;

[numthreads(1, 1, 1)]
void CSMain(uint id : SV_DispatchThreadID)
{   
    uint oldValue;
    
    uint baseIndex = id * 256;
    
    PolygonMeta polygon = inputPolygonBuffer[id];
    
    for (int a = polygon.opaqueStartIndex; a < polygon.opaqueStartIndex + polygon.opaqueCount; a++)
    {
        Triangle intri = inputTriangleBuffer[a];
    
        uint processverticescount = 0;
        uint processtexturescount = 0;
        uint processboolcount = 0;
    
        processVertices[baseIndex + processverticescount] = intri.v0;
        processVertices[baseIndex + processverticescount + 1] = intri.v1;
        processVertices[baseIndex + processverticescount + 2] = intri.v2;
        processverticescount += 3;
        processTextures[baseIndex + processtexturescount] = intri.uv0;
        processTextures[baseIndex + processtexturescount + 1] = intri.uv1;
        processTextures[baseIndex + processtexturescount + 2] = intri.uv2;
        processtexturescount += 3;
        processBool[baseIndex + processboolcount] = 0;
        processBool[baseIndex + processboolcount + 1] = 0;
        processBool[baseIndex + processboolcount + 2] = 0;
        processboolcount += 3;
    
        for (int b = polygon.planeStartIndex; b < polygon.planeStartIndex + polygon.planeCount; b++)
        {
            uint AddTriangles = 0;
            uint temporaryverticescount = 0;
            uint temporarytexturescount = 0;
    
            for (uint c = baseIndex; c < baseIndex + processverticescount; c += 3)
            {
                if (processBool[c] == 1 && processBool[c + 1] == 1 && processBool[c + 2] == 1)
                {
                    continue;
                }

                float3 v0 = processVertices[c];
                float3 v1 = processVertices[c + 1];
                float3 v2 = processVertices[c + 2];

                float4 uv0 = processTextures[c];
                float4 uv1 = processTextures[c + 1];
                float4 uv2 = processTextures[c + 2];
            
                float d0 = dot(planeBuffer[b].normal, v0) + (planeBuffer[b].distance);
                float d1 = dot(planeBuffer[b].normal, v1) + (planeBuffer[b].distance);
                float d2 = dot(planeBuffer[b].normal, v2) + (planeBuffer[b].distance);
            
                bool b0 = d0 >= 0;
                bool b1 = d1 >= 0;
                bool b2 = d2 >= 0;

                if (b0 && b1 && b2)
                {
                    continue;
                }
                else if ((b0 && !b1 && !b2) || (!b0 && b1 && !b2) || (!b0 && !b1 && b2))
                {
                    float3 inV, outV1, outV2;
                    float4 inUV, outUV1, outUV2;
                    float inD, outD1, outD2;

                    if (b0)
                    {
                        inV = v0;
                        inUV = uv0;
                        inD = d0;
                        outV1 = v1;
                        outUV1 = uv1;
                        outD1 = d1;
                        outV2 = v2;
                        outUV2 = uv2;
                        outD2 = d2;
                    }
                    else if (b1)
                    {
                        inV = v1;
                        inUV = uv1;
                        inD = d1;
                        outV1 = v2;
                        outUV1 = uv2;
                        outD1 = d2;
                        outV2 = v0;
                        outUV2 = uv0;
                        outD2 = d0;
                    }
                    else
                    {
                        inV = v2;
                        inUV = uv2;
                        inD = d2;
                        outV1 = v0;
                        outUV1 = uv0;
                        outD1 = d0;
                        outV2 = v1;
                        outUV2 = uv1;
                        outD2 = d1;
                    }

                    float t1 = inD / (inD - outD1);
                    float t2 = inD / (inD - outD2);

                    temporaryVertices[baseIndex + temporaryverticescount] = inV;
                    temporaryVertices[baseIndex + temporaryverticescount + 1] = lerp(inV, outV1, t1);
                    temporaryVertices[baseIndex + temporaryverticescount + 2] = lerp(inV, outV2, t2);
                    temporaryverticescount += 3;
                    temporaryTextures[baseIndex + temporarytexturescount] = inUV;
                    temporaryTextures[baseIndex + temporarytexturescount + 1] = lerp(inUV, outUV1, t1);
                    temporaryTextures[baseIndex + temporarytexturescount + 2] = lerp(inUV, outUV2, t2);
                    temporarytexturescount += 3;
                    processBool[c] = 1;
                    processBool[c + 1] = 1;
                    processBool[c + 2] = 1;

                    AddTriangles += 1;
                }
                else if ((!b0 && b1 && b2) || (b0 && !b1 && b2) || (b0 && b1 && !b2))
                {
                    float3 inV1, inV2, outV;
                    float4 inUV1, inUV2, outUV;
                    float inD1, inD2, outD;

                    if (!b0)
                    {
                        outV = v0;
                        outUV = uv0;
                        outD = d0;
                        inV1 = v1;
                        inUV1 = uv1;
                        inD1 = d1;
                        inV2 = v2;
                        inUV2 = uv2;
                        inD2 = d2;
                    }
                    else if (!b1)
                    {
                        outV = v1;
                        outUV = uv1;
                        outD = d1;
                        inV1 = v2;
                        inUV1 = uv2;
                        inD1 = d2;
                        inV2 = v0;
                        inUV2 = uv0;
                        inD2 = d0;
                    }
                    else
                    {
                        outV = v2;
                        outUV = uv2;
                        outD = d2;
                        inV1 = v0;
                        inUV1 = uv0;
                        inD1 = d0;
                        inV2 = v1;
                        inUV2 = uv1;
                        inD2 = d1;
                    }

                    float t1 = inD1 / (inD1 - outD);
                    float t2 = inD2 / (inD2 - outD);

                    float3 vA = lerp(inV1, outV, t1);
                    float3 vB = lerp(inV2, outV, t2);

                    float4 uvA = lerp(inUV1, outUV, t1);
                    float4 uvB = lerp(inUV2, outUV, t2);

                    temporaryVertices[baseIndex + temporaryverticescount] = inV1;
                    temporaryVertices[baseIndex + temporaryverticescount + 1] = inV2;
                    temporaryVertices[baseIndex + temporaryverticescount + 2] = vA;
                    temporaryverticescount += 3;
                    temporaryTextures[baseIndex + temporarytexturescount] = inUV1;
                    temporaryTextures[baseIndex + temporarytexturescount + 1] = inUV2;
                    temporaryTextures[baseIndex + temporarytexturescount + 2] = uvA;
                    temporarytexturescount += 3;
                    temporaryVertices[baseIndex + temporaryverticescount] = vA;
                    temporaryVertices[baseIndex + temporaryverticescount + 1] = inV2;
                    temporaryVertices[baseIndex + temporaryverticescount + 2] = vB;
                    temporaryverticescount += 3;
                    temporaryTextures[baseIndex + temporarytexturescount] = uvA;
                    temporaryTextures[baseIndex + temporarytexturescount + 1] = inUV2;
                    temporaryTextures[baseIndex + temporarytexturescount + 2] = uvB;
                    temporarytexturescount += 3;
                    processBool[c] = 1;
                    processBool[c + 1] = 1;
                    processBool[c + 2] = 1;

                    AddTriangles += 2;
                }
                else
                {
                    processBool[c] = 1;
                    processBool[c + 1] = 1;
                    processBool[c + 2] = 1;
                }
            }
            if (AddTriangles > 0)
            {
                for (uint d = baseIndex; d < baseIndex + temporaryverticescount; d += 3)
                {
                    processVertices[baseIndex + processverticescount] = temporaryVertices[d];
                    processVertices[baseIndex + processverticescount + 1] = temporaryVertices[d + 1];
                    processVertices[baseIndex + processverticescount + 2] = temporaryVertices[d + 2];
                    processverticescount += 3;
                    processTextures[baseIndex + processtexturescount] = temporaryTextures[d];
                    processTextures[baseIndex + processtexturescount + 1] = temporaryTextures[d + 1];
                    processTextures[baseIndex + processtexturescount + 2] = temporaryTextures[d + 2];
                    processtexturescount += 3;
                    processBool[baseIndex + processboolcount] = 0;
                    processBool[baseIndex + processboolcount + 1] = 0;
                    processBool[baseIndex + processboolcount + 2] = 0;
                    processboolcount += 3;
                }
            }
        }
        for (uint e = baseIndex; e < baseIndex + processboolcount; e += 3)
        {
            if (processBool[e] == 0 && processBool[e + 1] == 0 && processBool[e + 2] == 0)
            {
                Triangle triout;

                triout.v0 = processVertices[e];
                triout.v1 = processVertices[e + 1];
                triout.v2 = processVertices[e + 2];
                triout.uv0 = processTextures[e];
                triout.uv1 = processTextures[e + 1];
                triout.uv2 = processTextures[e + 2];
    
                outputTriangleBuffer.Append(triout);
            
                argsBuffer.InterlockedAdd(0, 3, oldValue);
            }
        }
    }
}
