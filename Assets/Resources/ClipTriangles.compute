#pragma kernel CSMain

struct Triangle
{
    float3 v0, v1, v2;
    float4 uv0, uv1, uv2;
};

struct MathematicalPlane
{
    float3 normal;
    float distance;
};

struct FrustumMeta
{
    int planeStartIndex;
    int planeCount;

    int frustumID;
};

AppendStructuredBuffer<Triangle> outputTriangleBuffer;
StructuredBuffer<Triangle> inputTriangleBuffer;
StructuredBuffer<MathematicalPlane> planeBuffer;
StructuredBuffer<FrustumMeta> frustumBuffer;
RWStructuredBuffer<float3> processVertices;
RWStructuredBuffer<float4> processTextures;
RWStructuredBuffer<bool> processBool;
RWStructuredBuffer<float3> temporaryVertices;
RWStructuredBuffer<float4> temporaryTextures;
RWStructuredBuffer<uint> argsBuffer;

float4 CamPosition;

[numthreads(1, 1, 1)]
void CSMain(uint id : SV_DispatchThreadID)
{
    Triangle intri = inputTriangleBuffer[id];
    
    FrustumMeta frustum = frustumBuffer[id];
    
    uint baseIndex = id * 256;
    
    float3 edge1 = intri.v1 - intri.v0;
    float3 edge2 = intri.v2 - intri.v0;
    float3 normal = normalize(cross(edge1, edge2));
    float3 camDir = normalize(CamPosition.xyz - intri.v0);
    float triangleDirection = dot(normal, camDir);

    if (triangleDirection < 0)
    {
        return;
    }
    
    uint processverticescount = 0;
    uint processtexturescount = 0;
    uint processboolcount = 0;
    
    processVertices[baseIndex + processverticescount] = intri.v0;
    processVertices[baseIndex + processverticescount + 1] = intri.v1;
    processVertices[baseIndex + processverticescount + 2] = intri.v2;
    processverticescount += 3;
    processTextures[baseIndex + processtexturescount] = intri.uv0;
    processTextures[baseIndex + processtexturescount + 1] = intri.uv1;
    processTextures[baseIndex + processtexturescount + 2] = intri.uv2;
    processtexturescount += 3;
    processBool[baseIndex + processboolcount] = true;
    processBool[baseIndex + processboolcount + 1] = true;
    processBool[baseIndex + processboolcount + 2] = true;
    processboolcount += 3;
    
    for (int b = frustum.planeStartIndex; b < frustum.planeStartIndex + frustum.planeCount; b++)
    {
        uint AddTriangles = 0;
        uint temporaryverticescount = 0;
        uint temporarytexturescount = 0;
    
        for (uint c = baseIndex; c < baseIndex + processverticescount; c += 3)
        {
            if (processBool[c] == false && processBool[c + 1] == false && processBool[c + 2] == false)
            {
                continue;
            }

            float3 v0 = processVertices[c];
            float3 v1 = processVertices[c + 1];
            float3 v2 = processVertices[c + 2];

            float4 uv0 = processTextures[c];
            float4 uv1 = processTextures[c + 1];
            float4 uv2 = processTextures[c + 2];
            
            float d0 = dot(planeBuffer[b].normal, processVertices[c]) + (planeBuffer[b].distance);
            float d1 = dot(planeBuffer[b].normal, processVertices[c + 1]) + (planeBuffer[b].distance);
            float d2 = dot(planeBuffer[b].normal, processVertices[c + 2]) + (planeBuffer[b].distance);
            
            bool b0 = d0 >= 0;
            bool b1 = d1 >= 0;
            bool b2 = d2 >= 0;

            if (b0 && b1 && b2)
            {
                continue;
            }
            else if ((b0 && !b1 && !b2) || (!b0 && b1 && !b2) || (!b0 && !b1 && b2))
            {
                float3 inV, outV1, outV2;
                float4 inUV, outUV1, outUV2;
                float inD, outD1, outD2;

                if (b0)
                {
                    inV = v0;
                    inUV = uv0;
                    inD = d0;
                    outV1 = v1;
                    outUV1 = uv1;
                    outD1 = d1;
                    outV2 = v2;
                    outUV2 = uv2;
                    outD2 = d2;
                }
                else if (b1)
                {
                    inV = v1;
                    inUV = uv1;
                    inD = d1;
                    outV1 = v2;
                    outUV1 = uv2;
                    outD1 = d2;
                    outV2 = v0;
                    outUV2 = uv0;
                    outD2 = d0;
                }
                else
                {
                    inV = v2;
                    inUV = uv2;
                    inD = d2;
                    outV1 = v0;
                    outUV1 = uv0;
                    outD1 = d0;
                    outV2 = v1;
                    outUV2 = uv1;
                    outD2 = d1;
                }

                float t1 = inD / (inD - outD1);
                float t2 = inD / (inD - outD2);

                temporaryVertices[baseIndex + temporaryverticescount] = inV;
                temporaryVertices[baseIndex + temporaryverticescount + 1] = lerp(inV, outV1, t1);
                temporaryVertices[baseIndex + temporaryverticescount + 2] = lerp(inV, outV2, t2);
                temporaryverticescount += 3;
                temporaryTextures[baseIndex + temporarytexturescount] = inUV;
                temporaryTextures[baseIndex + temporarytexturescount + 1] = lerp(inUV, outUV1, t1);
                temporaryTextures[baseIndex + temporarytexturescount + 2] = lerp(inUV, outUV2, t2);
                temporarytexturescount += 3;
                processBool[c] = false;
                processBool[c + 1] = false;
                processBool[c + 2] = false;

                AddTriangles += 1;
            }
            else if ((!b0 && b1 && b2) || (b0 && !b1 && b2) || (b0 && b1 && !b2))
            {
                float3 inV1, inV2, outV;
                float4 inUV1, inUV2, outUV;
                float inD1, inD2, outD;

                if (!b0)
                {
                    outV = v0;
                    outUV = uv0;
                    outD = d0;
                    inV1 = v1;
                    inUV1 = uv1;
                    inD1 = d1;
                    inV2 = v2;
                    inUV2 = uv2;
                    inD2 = d2;
                }
                else if (!b1)
                {
                    outV = v1;
                    outUV = uv1;
                    outD = d1;
                    inV1 = v2;
                    inUV1 = uv2;
                    inD1 = d2;
                    inV2 = v0;
                    inUV2 = uv0;
                    inD2 = d0;
                }
                else
                {
                    outV = v2;
                    outUV = uv2;
                    outD = d2;
                    inV1 = v0;
                    inUV1 = uv0;
                    inD1 = d0;
                    inV2 = v1;
                    inUV2 = uv1;
                    inD2 = d1;
                }

                float t1 = inD1 / (inD1 - outD);
                float t2 = inD2 / (inD2 - outD);

                float3 vA = lerp(inV1, outV, t1);
                float3 vB = lerp(inV2, outV, t2);

                float4 uvA = lerp(inUV1, outUV, t1);
                float4 uvB = lerp(inUV2, outUV, t2);

                temporaryVertices[baseIndex + temporaryverticescount] = inV1;
                temporaryVertices[baseIndex + temporaryverticescount + 1] = inV2;
                temporaryVertices[baseIndex + temporaryverticescount + 2] = vA;
                temporaryverticescount += 3;
                temporaryTextures[baseIndex + temporarytexturescount] = inUV1;
                temporaryTextures[baseIndex + temporarytexturescount + 1] = inUV2;
                temporaryTextures[baseIndex + temporarytexturescount + 2] = uvA;
                temporarytexturescount += 3;
                temporaryVertices[baseIndex + temporaryverticescount] = vA;
                temporaryVertices[baseIndex + temporaryverticescount + 1] = inV2;
                temporaryVertices[baseIndex + temporaryverticescount + 2] = vB;
                temporaryverticescount += 3;
                temporaryTextures[baseIndex + temporarytexturescount] = uvA;
                temporaryTextures[baseIndex + temporarytexturescount + 1] = inUV2;
                temporaryTextures[baseIndex + temporarytexturescount + 2] = uvB;
                temporarytexturescount += 3;
                processBool[c] = false;
                processBool[c + 1] = false;
                processBool[c + 2] = false;

                AddTriangles += 2;
            }
            else
            {
                processBool[c] = false;
                processBool[c + 1] = false;
                processBool[c + 2] = false;
            }
        }
        if (AddTriangles > 0)
        {
            for (uint d = baseIndex; d < baseIndex + temporaryverticescount; d += 3)
            {
                processVertices[baseIndex + processverticescount] = temporaryVertices[d];
                processVertices[baseIndex + processverticescount + 1] = temporaryVertices[d + 1];
                processVertices[baseIndex + processverticescount + 2] = temporaryVertices[d + 2];
                processverticescount += 3;
                processTextures[baseIndex + processtexturescount] = temporaryTextures[d];
                processTextures[baseIndex + processtexturescount + 1] = temporaryTextures[d + 1];
                processTextures[baseIndex + processtexturescount + 2] = temporaryTextures[d + 2];
                processtexturescount += 3;
                processBool[baseIndex + processboolcount] = true;
                processBool[baseIndex + processboolcount + 1] = true;
                processBool[baseIndex + processboolcount + 2] = true;
                processboolcount += 3;
            }
        }
    }
    for (uint e = baseIndex; e < baseIndex + processboolcount; e += 3)
    {
        if (processBool[e] == true && processBool[e + 1] == true && processBool[e + 2] == true)
        {
            Triangle triout;

            triout.v0 = processVertices[e];
            triout.v1 = processVertices[e + 1];
            triout.v2 = processVertices[e + 2];
            triout.uv0 = processTextures[e];
            triout.uv1 = processTextures[e + 1];
            triout.uv2 = processTextures[e + 2];
    
            outputTriangleBuffer.Append(triout);
            
            InterlockedAdd(argsBuffer[0], 3);
        }
    }
}
